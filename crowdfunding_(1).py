# -*- coding: utf-8 -*-
"""Crowdfunding (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19tACnFSU8cm0OEn2HwRqYMCI_0r00BKB
"""

!pip install web3 py-solc-x eth-tester

""" **WEEK 1**"""

!pip install web3 py-solc-x eth-tester==0.9.0b1 py-evm==0.7.0a2
!pip install web3 py-solc-x

from web3 import Web3, EthereumTesterProvider
from solcx import compile_source, install_solc


w3 = Web3(EthereumTesterProvider())


print(f"Connected: {w3.is_connected()}")
print(f"Test accounts: {w3.eth.accounts}")

# Install Solidity compiler
install_solc('0.8.0')

# Week 1 Contract Code
hello_world_code = """
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract HelloWorld {
    string public greeting;

    constructor() {
        greeting = "Hello, World!";
    }

    function setGreeting(string memory _greeting) public {
        greeting = _greeting;
    }

    function getGreeting() public view returns (string memory) {
        return greeting;
    }
}
"""


compiled = compile_source(hello_world_code, solc_version='0.8.0')
contract_id, contract_interface = compiled.popitem()


account = w3.eth.accounts[0]

HelloWorld = w3.eth.contract(abi=contract_interface['abi'], bytecode=contract_interface['bin'])
tx_hash = HelloWorld.constructor().transact({'from': account})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)


hello = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_interface['abi'])


print("Initial greeting:", hello.functions.getGreeting().call())


hello.functions.setGreeting("Hello from Google Colab!").transact({'from': account})
print("Updated greeting:", hello.functions.getGreeting().call())

""" **WEEK 2**"""

!pip install web3 py-solc-x

from web3 import Web3, EthereumTesterProvider
from solcx import compile_source, install_solc


w3 = Web3(EthereumTesterProvider())


print(f"Connected: {w3.is_connected()}")
print(f"Test accounts: {w3.eth.accounts}")

# Install Solidity compiler
install_solc('0.8.0')

# Week 2 - Campaign Structure
week2_code = """
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Crowdfunding {
    struct Campaign {
        address owner;
        string title;
        uint256 goal;
        uint256 deadline;
        uint256 totalFunds;
    }

    uint256 public campaignCount;
    mapping(uint256 => Campaign) public campaigns;

    function createCampaign(string memory _title, uint256 _goal, uint256 _days) public {
        campaignCount++;
        campaigns[campaignCount] = Campaign({
            owner: msg.sender,
            title: _title,
            goal: _goal,
            deadline: block.timestamp + (_days * 1 days),
            totalFunds: 0
        });
    }
}
"""


compiled = compile_source(week2_code, solc_version='0.8.0')
contract_id, contract_interface = compiled.popitem()


account = w3.eth.accounts[0]

Crowdfunding = w3.eth.contract(abi=contract_interface['abi'], bytecode=contract_interface['bin'])
tx_hash = Crowdfunding.constructor().transact({'from': account})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)


crowdfund = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_interface['abi'])

# Create a test campaign
crowdfund.functions.createCampaign(
    "My Project",
    w3.to_wei(10, 'ether'),
    7
).transact({'from': account})


print("Campaign count:", crowdfund.functions.campaignCount().call())
campaign = crowdfund.functions.campaigns(1).call()
print(f"Campaign 1: Title='{campaign[1]}', Goal={w3.from_wei(campaign[2], 'ether')} ETH")

"""**WEEK 3**"""

!pip install web3 py-solc-x

from web3 import Web3, EthereumTesterProvider
from solcx import compile_source, install_solc

w3 = Web3(EthereumTesterProvider())


print(f"Connected: {w3.is_connected()}")
print(f"Test accounts: {w3.eth.accounts}")


install_solc('0.8.0')

# Week 3 - Contributions
week3_code = """
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Crowdfunding {
    struct Campaign {
        address owner;
        string title;
        uint256 goal;
        uint256 deadline;
        uint256 totalFunds;
    }

    struct Contribution {
        address contributor;
        uint256 amount;
    }

    uint256 public campaignCount;
    mapping(uint256 => Campaign) public campaigns;
    mapping(uint256 => Contribution[]) public contributions;

    function createCampaign(string memory _title, uint256 _goal, uint256 _days) public {
        campaignCount++;
        campaigns[campaignCount] = Campaign({
            owner: msg.sender,
            title: _title,
            goal: _goal,
            deadline: block.timestamp + (_days * 1 days),
            totalFunds: 0
        });
    }

    function contribute(uint256 _campaignId) public payable {
        require(_campaignId <= campaignCount, "Invalid campaign");
        Campaign storage c = campaigns[_campaignId];
        require(block.timestamp < c.deadline, "Campaign ended");

        c.totalFunds += msg.value;
        contributions[_campaignId].push(Contribution(msg.sender, msg.value));
    }
}
"""

compiled = compile_source(week3_code, solc_version='0.8.0')
contract_id, contract_interface = compiled.popitem()

account = w3.eth.accounts[0]

Crowdfunding = w3.eth.contract(abi=contract_interface['abi'], bytecode=contract_interface['bin'])
tx_hash = Crowdfunding.constructor().transact({'from': account})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)


crowdfund = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_interface['abi'])


crowdfund.functions.createCampaign(
    "New Project",
    w3.to_wei(5, 'ether'),
    3
).transact({'from': account})


contributor = w3.eth.accounts[1]
crowdfund.functions.contribute(1).transact({
    'from': contributor,
    'value': w3.to_wei(1, 'ether')
})


print("Campaign count:", crowdfund.functions.campaignCount().call())
campaign = crowdfund.functions.campaigns(1).call()
print(f"Campaign 1 balance: {w3.from_wei(campaign[4], 'ether')} ETH")

"""**WEEK 4**"""

!pip install web3 py-solc-x

from web3 import Web3, EthereumTesterProvider
from solcx import compile_source, install_solc
import time


w3 = Web3(EthereumTesterProvider())


print(f"Connected: {w3.is_connected()}")
print(f"Test accounts: {w3.eth.accounts}")

# Install Solidity compiler
install_solc('0.8.0')

# Week 4 - Complete Contract
final_code = """
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Crowdfunding {
    struct Campaign {
        address owner;
        string title;
        uint256 goal;
        uint256 deadline;
        uint256 totalFunds;
        bool funded;
    }

    struct Contribution {
        address contributor;
        uint256 amount;
    }

    uint256 public campaignCount;
    mapping(uint256 => Campaign) public campaigns;
    mapping(uint256 => Contribution[]) public contributions;

    event CampaignCreated(uint256 id, address owner, string title);
    event Funded(uint256 campaignId, uint256 amount);
    event Refunded(address contributor, uint256 amount);

    function createCampaign(string memory _title, uint256 _goal, uint256 _days) public {
        campaignCount++;
        campaigns[campaignCount] = Campaign({
            owner: msg.sender,
            title: _title,
            goal: _goal,
            deadline: block.timestamp + (_days * 1 days),
            totalFunds: 0,
            funded: false
        });
        emit CampaignCreated(campaignCount, msg.sender, _title);
    }

    function contribute(uint256 _campaignId) public payable {
        Campaign storage c = campaigns[_campaignId];
        require(!c.funded, "Campaign already completed");
        require(block.timestamp < c.deadline, "Campaign ended");

        c.totalFunds += msg.value;
        contributions[_campaignId].push(Contribution(msg.sender, msg.value));
    }

    function withdrawFunds(uint256 _campaignId) public {
        Campaign storage c = campaigns[_campaignId];
        require(msg.sender == c.owner, "Only owner can withdraw");
        require(block.timestamp >= c.deadline, "Campaign not ended");
        require(c.totalFunds >= c.goal, "Goal not reached");

        c.funded = true;
        payable(msg.sender).transfer(c.totalFunds);
        emit Funded(_campaignId, c.totalFunds);
    }

    function claimRefund(uint256 _campaignId) public {
        Campaign storage c = campaigns[_campaignId];
        require(block.timestamp >= c.deadline, "Campaign not ended");
        require(c.totalFunds < c.goal, "Goal was reached");

        uint256 totalRefund;
        Contribution[] storage contribs = contributions[_campaignId];

        for(uint i=0; i<contribs.length; i++) {
            if(contribs[i].contributor == msg.sender) {
                totalRefund += contribs[i].amount;
                contribs[i].amount = 0;
            }
        }

        require(totalRefund > 0, "No contributions found");
        payable(msg.sender).transfer(totalRefund);
        emit Refunded(msg.sender, totalRefund);
    }

    function getCurrentTime() public view returns (uint256) {
        return block.timestamp;
    }
}
"""


compiled = compile_source(final_code, solc_version='0.8.0')
contract_id, contract_interface = compiled.popitem()


account = w3.eth.accounts[0]

final_contract = w3.eth.contract(abi=contract_interface['abi'], bytecode=contract_interface['bin'])
tx_hash = final_contract.constructor().transact({'from': account})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

final_contract = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_interface['abi'])

print("\n1. Creating campaign...")
final_contract.functions.createCampaign(
    "Final Project",
    w3.to_wei(3, 'ether'),
    1
).transact({'from': account})


current_time = final_contract.functions.getCurrentTime().call()
print(f"Current block time: {current_time}")

print("\n2. Making contribution...")
contributor = w3.eth.accounts[1]
final_contract.functions.contribute(1).transact({
    'from': contributor,
    'value': w3.to_wei(4, 'ether')
})


campaign = final_contract.functions.campaigns(1).call()
print(f"\n3. Before deadline:")
print(f"Total raised: {w3.from_wei(campaign[4], 'ether')} ETH")
print(f"Funded status: {'Yes' if campaign[5] else 'No'}")
print(f"Deadline: {campaign[3]} (current: {final_contract.functions.getCurrentTime().call()})")


print("\n4. Fast-forwarding time...")
w3.testing.timeTravel(current_time + 86400 + 1)


new_time = final_contract.functions.getCurrentTime().call()
print(f"New block time: {new_time} (+{new_time - current_time} seconds)")


print("\n5. Withdrawing funds...")
final_contract.functions.withdrawFunds(1).transact({'from': account})

# Check final results
campaign = final_contract.functions.campaigns(1).call()
print(f"\n6. After deadline:")
print(f"Total raised: {w3.from_wei(campaign[4], 'ether')} ETH")
print(f"Funded status: {'Yes' if campaign[5] else 'No'}")

